<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chat</title>
  <link rel="icon" href="../images/AP_favicon.png">

  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/leaflet-rotatedmarker@0.2.0/leaflet.rotatedMarker.min.js"></script>

  <script type="text/javascript" src="MAVLink/mavlink.js"></script>
  <link rel="stylesheet" href="style.css">
</head>
<!-- <table style="width:1200px">
    <tr>
        <td>
            <a href="https://ardupilot.org"><img src="../images/ArduPilot.png"></a>
        </td>
        <td>
            <a href="https://github.com/ArduPilot/WebTools"><img src="../images/github-mark.png"
                    style="width:60px"></a><br>
            <a href="https://github.com/ArduPilot/WebTools"><img src="../images/GitHub_Logo.png" style="width:60px"></a>
        </td>
    </tr>
</table> -->

<!-- <style>
    body {
        font-family: Arial, sans-serif;
    }

    .chat-container {
        width: 400px;
        border: 1px solid #ccc;
        border-radius: 5px;
        padding: 10px;
        background-color: #f9f9f9;
    }

    .chat-box {
        width: 100%;
        height: 200px;
        border: 1px solid #ccc;
        background-color: white;
        padding: 5px;
        overflow-y: auto;
    }

    .user-text {
        color: red;
    }

    .assistant-text {
        color: black;
    }

    .input-container {
        display: flex;
        margin-top: 10px;
    }

    .input-field {
        flex: 1;
        padding: 5px;
    }

    .send-button {
        margin-left: 5px;
    } 
</style> -->

<!-- <h1><a href="" style="color: #000000; text-decoration:none;">Chat</a></h1> -->

<body class="bg-gray-100 font-inter antialiased">
  <div class="container mx-auto p-4">
    <h1 class="text-3xl font-semibold text-blue-600 text-center mb-6">ArduPilot AI Chat Control</h1>

    <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
      <!-- AI Chat Panel -->
      <div class="bg-white shadow-md rounded-lg p-4 flex flex-col">
        <div class="flex items-center gap-4 mb-4">
          <h2 class="text-xl font-semibold">AI Chat Interface</h2>
          <!-- <span id="connection-status"
                        class="ml-auto inline-flex items-center rounded-full bg-red-500 px-2.5 py-0.5 text-xs font-semibold text-white">
                        Disconnected
                    </span> -->
        </div>

        <div id="chatBox" class="flex-1 overflow-y-auto space-y-3 mb-4 flex flex-col max-h-[73vh]">
          <div class="chat-message-bot">
            <p class="text-sm">Welcome! I'm your ArduPilot AI assistant. You can control the drone using
              natural language commands like:</p>
            <ul class="list-disc pl-5 mt-2 text-sm">
              <li>"Arm the drone"</li>
              <li>"Take off to 10 meters"</li>
              <li>"Fly north for 50 meters"</li>
              <li>"Return to launch"</li>
              <li>"Change to guided mode"</li>
              <li>"Emergency stop"</li>
            </ul>
          </div>
        </div>

        <div class="flex items-center gap-2">
          <input type="text" id="userInput" placeholder="Type your command or question..."
            class="flex-1 rounded-md border-gray-300 shadow-sm p-3 focus:ring-blue-500 focus:border-blue-500"
            autocomplete="off">
          <button id="sendMessageButton" class="bg-blue-500 hover:bg-blue-600 text-white rounded-md p-3">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
              <path
                d="M10.894 2.553a1 1 0 00-1.788 0l-7 14a1 1 0 001.169 1.409l5-1.429A1 1 0 009 15.571V11a1 1 0 112 0v4.571a1 1 0 00.725.962l5 1.428a1 1 0 001.17-1.408l-7-14z" />
            </svg>
          </button>
          <button id="recordButton" class="bg-purple-500 hover:bg-purple-600 text-white rounded-md p-3">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
              <path fill-rule="evenodd"
                d="M7 4a3 3 0 016 0v4a3 3 0 11-6 0V4zm4 10.93A7.001 7.001 0 0017 8a1 1 0 10-2 0A5 5 0 015 8a1 1 0 00-2 0 7.001 7.001 0 006 6.93V17H6a1 1 0 100 2h8a1 1 0 100-2h-3v-2.07z"
                clip-rule="evenodd" />
            </svg>
          </button>
        </div>

        <div id="command-history" class="command-history mt-2 hidden">
          <!-- Command history items will be added here -->
        </div>

        <div class="grid grid-cols-1 sm:grid-cols-[minmax(0,1fr)_80px_auto] gap-2 mt-4">
          <!-- QGC Address -->
          <input type="text" id="mavlink-connect-url" class="rounded-md border-gray-300 shadow-sm p-2 w-full"
            value="ws://127.0.0.1:56781" readonly>

          <!-- Target ID -->
          <input type="number" id="target-id" placeholder="ID" value="1" min="1"
            class="rounded-md border-gray-300 shadow-sm p-2 w-full text-center">

          <!-- Single stateful button -->
          <button id="mavlink-connect-button"
            class="bg-green-500 hover:bg-green-600 text-white rounded-md px-4 py-2 whitespace-nowrap w-full">
            Connect
          </button>
        </div>
      </div>

      <!-- Telemetry Panel -->
      <div class="bg-white shadow-md rounded-lg p-4">
        <h2 class="text-xl font-semibold mb-4">Vehicle Telemetry</h2>

        <div class="grid grid-cols-2 gap-4 mb-4">
          <div class="bg-gray-50 p-3 rounded">
            <div class="text-sm text-gray-500">Flight Mode</div>
            <div id="flight-mode" class="text-xl font-bold text-blue-600">DISCONNECTED</div>
          </div>
          <div class="bg-gray-50 p-3 rounded">
            <div class="text-sm text-gray-500">Armed State</div>
            <div id="armed-state" class="text-xl font-bold text-red-600">DISARMED</div>
          </div>
          <div class="bg-gray-50 p-3 rounded">
            <div class="text-sm text-gray-500">Battery</div>
            <div class="flex items-center gap-2">
              <div id="battery-voltage" class="text-xl font-bold">-.- V</div>
              <div class="battery-indicator flex-1">
                <div id="battery-level" class="battery-level" style="width: 0%"></div>
              </div>
            </div>
          </div>
          <div class="bg-gray-50 p-3 rounded">
            <div class="text-sm text-gray-500">GPS Status</div>
            <div id="gps-status" class="text-xl font-bold">NO FIX</div>
          </div>
        </div>

        <div class="mb-4">
          <h3 class="font-medium mb-2">Attitude Indicator</h3>
          <div class="attitude-indicator h-32 rounded-md relative">
            <div class="absolute inset-0 grid grid-cols-3 grid-rows-3">
              <div class="border-r border-b border-white opacity-20"></div>
              <div class="border-r border-b border-white opacity-20"></div>
              <div class="border-b border-white opacity-20"></div>
              <div class="border-r border-white opacity-20"></div>
              <div class="border-r border-white opacity-20"></div>
              <div class="border-white opacity-20"></div>
              <div class="border-r border-t border-white opacity-20"></div>
              <div class="border-r border-t border-white opacity-20"></div>
              <div class="border-t border-white opacity-20"></div>
            </div>
            <div class="attitude-horizon"></div>
            <div id="attitude-ball" class="attitude-ball"></div>
          </div>
          <div class="grid grid-cols-3 gap-2 mt-2">
            <div class="text-center">
              <div class="text-sm text-gray-500">Roll</div>
              <div id="roll-value" class="font-mono">0.0°</div>
            </div>
            <div class="text-center">
              <div class="text-sm text-gray-500">Pitch</div>
              <div id="pitch-value" class="font-mono">0.0°</div>
            </div>
            <div class="text-center">
              <div class="text-sm text-gray-500">Yaw</div>
              <div id="yaw-value" class="font-mono">0.0°</div>
            </div>
          </div>
        </div>

        <div>
          <h3 class="font-medium mb-2">Flight Mode</h3>
          <div class="flex gap-2">
            <select id="flight-mode-select" class="flex-1 rounded-md border p-2">
              <option value="STABILIZE">Stabilize</option>
              <option value="ACRO">Acro</option>
              <option value="ALT_HOLD">Altitude Hold</option>
              <option value="AUTO">Auto</option>
              <option value="GUIDED">Guided</option>
              <option value="LOITER">Loiter</option>
              <option value="RTL">Return to Launch</option>
              <option value="CIRCLE">Circle</option>
              <option value="LAND">Land</option>
              <option value="DRIFT">Drift</option>
              <option value="POSHOLD">Position Hold</option>
            </select>
            <button id="set-mode-btn" class="bg-blue-500 hover:bg-blue-600 text-white px-4 rounded">
              Set
            </button>
          </div>
        </div>

        <div class="mt-4 border-t pt-4 border-gray-200">
          <h3 class="text-lg font-semibold mb-3">AI Configuration</h3>

          <div class="mb-3">
            <label for="openai_api_key" class="block text-sm font-medium text-gray-700 mb-1">OpenAI API
              Key:</label>
            <div class="flex gap-2">
              <input type="password" id="openai_api_key" class="flex-1 rounded-md border-gray-300 shadow-sm p-3"
                autocomplete="off">
              <button id="toggleApiKeyButton" class="bg-blue-500 hover:bg-blue-600 text-white rounded-md p-3"> <svg
                  id="eyeIcon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor"
                  class="h-5 w-5">
                  <path fill-rule="evenodd"
                    d="M3.28 2.22a.75.75 0 0 0-1.06 1.06l14.5 14.5a.75.75 0 1 0 1.06-1.06l-1.745-1.745a10.029 10.029 0 0 0 3.3-4.38 1.651 1.651 0 0 0 0-1.185A10.004 10.004 0 0 0 9.999 3a9.956 9.956 0 0 0-4.744 1.194L3.28 2.22ZM7.752 6.69l1.092 1.092a2.5 2.5 0 0 1 3.374 3.373l1.091 1.092a4 4 0 0 0-5.557-5.557Z"
                    clip-rule="evenodd" />
                  <path
                    d="m10.748 13.93 2.523 2.523a9.987 9.987 0 0 1-3.27.547c-4.258 0-7.894-2.66-9.337-6.41a1.651 1.651 0 0 1 0-1.186A10.007 10.007 0 0 1 2.839 6.02L6.07 9.252a4 4 0 0 0 4.678 4.678Z" />
                </svg>
              </button>
            </div>
          </div>


          <div class="mb-3">
            <label for="assistantId" class="block text-sm font-medium text-gray-700 mb-1">Assistant
              ID:</label>
            <input type="text" id="assistantId" class="w-full rounded-md border-gray-300 shadow-sm p-2 bg-gray-50"
              readonly>
          </div>

          <div class="mb-3">
            <label for="assistantThreadId" class="block text-sm font-medium text-gray-700 mb-1">Thread
              ID:</label>
            <input type="text" id="assistantThreadId" class="w-full rounded-md border-gray-300 shadow-sm p-2 bg-gray-50"
              readonly>
          </div>

          <div class="mb-3">
            <label for="assistantRunStatus" class="block text-sm font-medium text-gray-700 mb-1">Run
              Status:</label>
            <input type="text" id="assistantRunStatus"
              class="w-full rounded-md border-gray-300 shadow-sm p-2 bg-gray-50" readonly>
          </div>
        </div>

      </div>

      <!-- Map and Position Panel -->
      <div class="bg-white shadow-md rounded-lg p-4">
        <h2 class="text-xl font-semibold mb-4">Position Tracking</h2>

        <div id="map" class="rounded-md mb-4"></div>

        <div class="grid grid-cols-3 gap-2 mb-4">
          <div class="bg-gray-50 p-2 rounded">
            <div class="text-xs text-gray-500">Latitude</div>
            <div id="lat-value" class="font-mono text-sm">0.000000</div>
          </div>
          <div class="bg-gray-50 p-2 rounded">
            <div class="text-xs text-gray-500">Longitude</div>
            <div id="lon-value" class="font-mono text-sm">0.000000</div>
          </div>
          <div class="bg-gray-50 p-2 rounded">
            <div class="text-xs text-gray-500">Altitude</div>
            <div id="alt-value" class="font-mono text-sm">0.0 m</div>
          </div>
        </div>

        <div class="mb-4">
          <h3 class="font-medium mb-2">Pre-Flight Checks</h3>
          <div id="preflight-results" class="space-y-2">
            <div class="text-center text-gray-500 py-4">Not connected</div>
          </div>
          <button id="preflight-btn" class="w-full mt-2 bg-blue-500 hover:bg-blue-600 text-white py-2 rounded-md">
            Run Pre-Flight Checks
          </button>
        </div>

        <div>
          <h3 class="font-medium mb-2">Quick Commands</h3>
          <div class="grid grid-cols-2 gap-2">
            <button id="mavlink-arm-button" class="bg-green-500 hover:bg-green-600 text-white p-2 rounded">Arm</button>
            <button id="mavlink-disarm-button"
              class="bg-red-500 hover:bg-red-600 text-white p-2 rounded">Disarm</button>
            <button id="takeoff-btn" class="bg-blue-500 hover:bg-blue-600 text-white p-2 rounded">Takeoff</button>
            <button id="land-btn" class="bg-yellow-500 hover:bg-yellow-600 text-white p-2 rounded">Land</button>
            <button id="rtl-btn" class="bg-purple-500 hover:bg-purple-600 text-white p-2 rounded">RTL</button>
            <button id="emergency-btn" class="bg-red-700 hover:bg-red-800 text-white p-2 rounded">Emergency
              Stop</button>
          </div>
        </div>

        <!-- DEBUG OUTPUT CONTAINER -->
        <div class="mt-4 border-t pt-4 border-gray-200">
          <label for="debugOutput" class="block text-sm font-medium text-gray-700 mb-1">Debug Output:</label>
          <textarea id="debugOutput"
            class="w-full rounded-md border-gray-300 shadow-sm p-2 text-xs font-mono bg-gray-50" rows="10" readonly>
                    </textarea>
        </div>

      </div>
    </div>
  </div>

  <!-- <script src="script.js"></script> -->
  <script src="shared.js"></script>
  <!-- simple script functions local to this page -->
  <script type="module">
    // imports
    import { mavlink_store } from './MAVLink/mavlink_store.js';
    import { setMAVLink, setMavlinkWS } from './shared.js';



    // show/hide the OpenAI API key field
    function toggle_openai_api_key_visibility() {
      let openai_key_input = document.getElementById("openai_api_key");
      const eyeIconContainer = document.getElementById("eyeIcon"); // Get reference to the SVG element
      // openai_key_input.type = openai_key_input.type === "password" ? "text" : "password";
      // Eye Icon (Open) - Standard 20x20 Solid Heroicon
      const eyeOpenSVGPath = `
                <path d="M10 12.5a2.5 2.5 0 1 0 0-5 2.5 2.5 0 0 0 0 5Z" />
                <path fill-rule="evenodd" d="M.664 10.59a1.651 1.651 0 0 1 0-1.186A10.004 10.004 0 0 1 10 3c4.257 0 7.893 2.66 9.336 6.41.147.381.146.804 0 1.186A10.004 10.004 0 0 1 10 17c-4.257 0-7.893-2.66-9.336-6.41ZM14 10a4 4 0 1 1-8 0 4 4 0 0 1 8 0Z" clip-rule="evenodd" />
            `;

      // Eye-Slash Icon (Closed) - Standard 20x20 Solid Heroicon
      const eyeClosedSVGPath = `
                <path fill-rule="evenodd" d="M3.28 2.22a.75.75 0 0 0-1.06 1.06l14.5 14.5a.75.75 0 1 0 1.06-1.06l-1.745-1.745a10.029 10.029 0 0 0 3.3-4.38 1.651 1.651 0 0 0 0-1.185A10.004 10.004 0 0 0 9.999 3a9.956 9.956 0 0 0-4.744 1.194L3.28 2.22ZM7.752 6.69l1.092 1.092a2.5 2.5 0 0 1 3.374 3.373l1.091 1.092a4 4 0 0 0-5.557-5.557Z" clip-rule="evenodd" />
                <path d="m10.748 13.93 2.523 2.523a9.987 9.987 0 0 1-3.27.547c-4.258 0-7.894-2.66-9.337-6.41a1.651 1.651 0 0 1 0-1.186A10.007 10.007 0 0 1 2.839 6.02L6.07 9.252a4 4 0 0 0 4.678 4.678Z" />
            `;

      if (openai_key_input.type === "password") {
        openai_key_input.type = "text";
        // Change icon to 'eye open'
        eyeIconContainer.innerHTML = eyeOpenSVGPath;
      } else {
        openai_key_input.type = "password";
        // Change icon to 'eye slash'
        eyeIconContainer.innerHTML = eyeClosedSVGPath;
      }
    }
    // listener for toggle api key visibility button click
    document.getElementById("toggleApiKeyButton").addEventListener("click", toggle_openai_api_key_visibility);

    // MAVLink connection related functions
    let connect_button = document.getElementById("mavlink-connect-button");
    let is_connected = false; // connection state
    let mavlink_ws = null; // websocket object
    let mavlink_sysid = 254; // system id
    let mavlink_compid = MAVLink20Processor.MAV_COMP_ID_MISSIONPLANNER; // component id
    let MAVLink = new MAVLink20Processor(null, mavlink_sysid, mavlink_compid);

    // set the MAVLink processor 
    setMAVLink(MAVLink);

    // toggle connection state (called by Connect/Disconnect button)
    function mavlink_toggle_connect() {
      if (is_connected) {
        mavlink_disconnect();
      } else {
        mavlink_connect();
      }
    }

    // attach event listener to the connect button
    if (connect_button) {
      connect_button.addEventListener("click", mavlink_toggle_connect);
    }

    // set the mavlink button connection state
    function mavlink_set_connect_state(connected) {
      is_connected = connected;
      if (connected) {
        connect_button.innerText = "Disconnect";
      } else {
        connect_button.innerText = "Connect";
      }
    }

    // connect to the vehicle
    function mavlink_connect() {
      // check connection URL
      let connect_url = document.getElementById("mavlink-connect-url").value;
      if (!connect_url) {
        alert("Error: WebSocket URL is empty");
        return;
      }

      if (mavlink_ws == null) {
        // create a new websocket connection
        mavlink_ws = new WebSocket(connect_url);
        mavlink_ws.binaryType = "arraybuffer"

        // set up event handlers
        mavlink_ws.onopen = function () {
          mavlink_set_connect_state(true);
        };
        mavlink_ws.onclose = function () {
          mavlink_set_connect_state(false);
        };
        mavlink_ws.onerror = function () {
          mavlink_disconnect();
        };

        // parse incoming message and forward
        mavlink_ws.onmessage = (msg) => {
          // sanity check parser has been created
          if (MAVLink == null) {
            return;
          }
          // parse message
          for (const char of new Uint8Array(msg.data)) {
            const mavlink_msg = MAVLink.parseChar(char)
            if ((mavlink_msg != null) && (mavlink_msg._id != -1)) {
              // got a message with a known ID
              mavlink_msg_handler(mavlink_msg);
            }
          }
        }
      }
      // set the mavlink websocket connection
      setMavlinkWS(mavlink_ws);
    }

    // disconnect from the vehicle
    function mavlink_disconnect() {
      if (mavlink_ws != null) {
        mavlink_ws.close();
        mavlink_ws = null;
      }
    }

    // mavlink message handler
    function mavlink_msg_handler(msg) {

      // sanity check msg
      if (msg == null || msg._id == null) {
        return;
      }

      // store the message in the message store
      mavlink_store.store_message(msg);

      switch (msg._id) {
        case 0: // HEARTBEAT
          //alert("custom mode:" + msg.custom_mode);
          //alert("Got a heartbeat: " + JSON.stringify(msg));
          break;
        case 1: // SYS_STATUS
          //alert("Got a system status: " + JSON.stringify(msg));
          break;
        case 24: // GPS_RAW_INT
          //alert("Got a GPS raw int: " + JSON.stringify(msg));
          break;
        case 30: // ATTITUDE
          //alert("Got an attitude: " + JSON.stringify(msg));
          break;
        case 33: // GLOBAL_POSITION_INT
          //alert("Got a global position int: " + JSON.stringify(msg));
          break;
        case 35: // HIGHRES_IMU
          //alert("Got a high resolution IMU: " + JSON.stringify(msg));
          break;
        case 42: // NAMED_VALUE_FLOAT
          //alert("Got a named value float: " + JSON.stringify(msg));
          break;
        case 74: // VFR_HUD
          //alert("Got a VFR HUD: " + JSON.stringify(msg));
          break;
        case 253: // STATUSTEXT
          //alert("Got a status text: " + JSON.stringify(msg));
          break;
        default:
          //alert("Got a message id: " + JSON.stringify(msg));
          break;
      }
    }

    // arm the vehicle
    function mavlink_arm_vehicle() {
      if (mavlink_ws == null || mavlink_ws.readyState !== WebSocket.OPEN) {
        alert("Please connect to the vehicle first");
        return;
      }
      // construct the ARM command using COMMAND_LONG
      let command_long_msg = new mavlink20.messages.command_long(
        1,   // Target system ID
        1,  // Target component ID
        400,             // MAV_CMD_COMPONENT_ARM_DISARM (command ID 400)
        1,               // Confirmation
        1,               // Param1: 1 to arm, 0 to disarm
        0, 0, 0, 0, 0, 0 // Unused parameters
      );

      const buffer = MAVLink.send(command_long_msg)
      const uint = new Uint8Array(buffer)

      // send the message as an ArrayBuffer over the WebSocket
      if (mavlink_ws && mavlink_ws.readyState === WebSocket.OPEN) {
        mavlink_ws.send(uint);
        add_text_to_debug("Sent ARM command via MAVLink");
      } else {
        alert("WebSocket is not open. Cannot send ARM command.");
      }
    }
    // disarm the vehicle
    function mavlink_disarm_vehicle() {
      if (mavlink_ws == null || mavlink_ws.readyState !== WebSocket.OPEN) {
        alert("Please connect to the vehicle first");
        return;
      }
      // construct the DISARM command using COMMAND_LONG
      let command_long_msg = new mavlink20.messages.command_long(
        1,   // Target system ID
        1,  // Target component ID
        400,             // MAV_CMD_COMPONENT_ARM_DISARM (command ID 400)
        1,               // Confirmation
        0,               // Param1: 1 to arm, 0 to disarm
        0, 0, 0, 0, 0, 0 // Unused parameters
      );

      const buffer = MAVLink.send(command_long_msg)
      const uint = new Uint8Array(buffer)

      // send the message as an ArrayBuffer over the WebSocket
      if (mavlink_ws && mavlink_ws.readyState === WebSocket.OPEN) {
        mavlink_ws.send(uint);
        add_text_to_debug("Sent DISARM command via MAVLink");
      } else {
        alert("WebSocket is not open. Cannot send DISARM command.");
      }
    }

    // attach event listener to the arm button
    document.getElementById("mavlink-arm-button").addEventListener("click", mavlink_arm_vehicle);
    // attach event listener to the disarm the vehicle
    document.getElementById("mavlink-disarm-button").addEventListener("click", mavlink_disarm_vehicle);

    // add text to debug text box
    function add_text_to_debug(text) {
      let debugOutput = document.getElementById("debugOutput");
      debugOutput.value += text + "\n";
      debugOutput.scrollTop = debugOutput.scrollHeight;
    }
  </script>

  <script type="module">
    // error handling
    window.onerror = function (msg, url, linenumber) {
      alert('Sorry, something went wrong.\n\n' +
        'Please try a hard reload of this page to clear its cache.\n\n' +
        'If the error persists open an issue on the GitHub repo.\n' +
        'Include a copy of the log and the following error message:\n\n' +
        msg + '\n' +
        'URL: ' + url + '\n' +
        'Line Number: ' + linenumber)
      return false
    }
    window.addEventListener('unhandledrejection', function (e) {
      throw new Error(e.reason.stack)
    })

    // imports
    import OpenAI from 'https://cdn.jsdelivr.net/npm/openai@4.85.4/+esm'
    import EventEmitter from 'https://cdn.jsdelivr.net/npm/eventemitter3@5.0.1/+esm'
    import { mavlink_store } from './MAVLink/mavlink_store.js';
    // import the shared functions
    import { MAVLink, mavlink_ws } from './shared.js';

    // constants
    const OPENAI_API_KEY = "your_api_key"; // replace with your OpenAI API key
    const OPENAI_MODEL = "gpt-4o"
    const OPENAI_ASSISTANT_NAME = "ArduPilot Vehicle Control via MAVLink"

    // global variables 
    window.openai = null
    window.openai_assistant_id = null
    window.openai_thread_id = null
    window.openai_event_handler = null

    // chat listener for user input and enter key
    document.getElementById("userInput").addEventListener("keypress", function (event) {
      if (event.key === "Enter") {
        send_message();
      }
    })
    // listener for send message button click
    document.getElementById("sendMessageButton").addEventListener("click", send_message);

    // get openai API key (use this in API calls)
    function get_openai_api_key() {
      if (OPENAI_API_KEY.length > 0) {
        return OPENAI_API_KEY;
      }
      return document.getElementById("openai_api_key").value.trim();
    }

    // check connection
    check_connection();

    // global variable to store wakeup messages
    let wakeup_schedule = [];
    window.onload = function () {
      // initialize the check wakeup:
      check_wakeup_timers();
    };

    // add text to chat box
    function add_text_to_chat(text, role = "assistant") {
      let div_class = role === "assistant" ? "assistant-text" : "user-text";
      let chatBox = document.getElementById("chatBox");

      if (role === "assistant") {
        // try to find the last assistant message and append to it
        let last_message = chatBox.querySelector(`.${div_class}:last-of-type`);
        if (last_message) {
          last_message.textContent += text;
          chatBox.scrollTop = chatBox.scrollHeight;
          return;
        }
      }

      // create a new message div if no previous assistant message exists
      let message_div = document.createElement("div");
      message_div.className = div_class;
      message_div.textContent = text;
      chatBox.appendChild(message_div);
      chatBox.scrollTop = chatBox.scrollHeight;
    }

    // add text to debug text box
    function add_text_to_debug(text) {
      let debugOutput = document.getElementById("debugOutput");
      debugOutput.value += text + "\n";
      debugOutput.scrollTop = debugOutput.scrollHeight;
    }

    // send message to AI assistant, get response and place in chat box text area
    async function send_message() {
      // check connection to OpenAI
      if (!(await check_connection())) {
        return;
      }

      let userInput = document.getElementById("userInput").value;
      if (!userInput.trim()) return;

      // display user input and clear input field
      add_text_to_chat(userInput, "user");
      document.getElementById("userInput").value = "";

      // fetch response from assistant
      let response = await get_assistant_response(userInput);

      // display assistant response
      add_text_to_chat(response, "assistant");
    }

    // send a message to the assistant, used for wakeup messages
    async function send_to_assistant(message) {
      // check connection
      if (!(await check_connection())) {
        return;
      }

      // sanity check message
      if (!message || message.trim() === "") {
        add_text_to_debug("send_to_assistant: message is empty");
        return;
      }

      // show the message in chat as system or wakeup message
      add_text_to_chat(message, "user"); // use "system" or custom style class
      // debugmu?

      // get assistant response
      let response = await get_assistant_response(message);

      // show assistant response
      add_text_to_chat(response, "assistant");
      // debugmu?
    }

    //
    // methods below here interact directly with the OpenAI API
    //

    // check connection to OpenAI API and return true on succes, false on failure
    async function check_connection() {
      // check openai API key
      if (!get_openai_api_key()) {
        return false;
      }
      // check openai connection
      if (!openai) {
        openai = new OpenAI({ apiKey: get_openai_api_key(), dangerouslyAllowBrowser: true });
        if (!openai) {
          return false;
        }
      }

      // return immediately if assistant id has already been found
      if (openai_assistant_id) {
        return true
      }

      let assistantId = await find_assistant(OPENAI_ASSISTANT_NAME);
      if (assistantId) {
        // store assistant id
        openai_assistant_id = assistantId
        document.getElementById("assistantId").value = assistantId;

        // create a new thread
        openai_thread_id = await create_thread();
        if (!openai_thread_id) {
          alert("Error: Unable to create a new OpenAI thread");
          return false;
        }
        // print thread id on the page
        document.getElementById("assistantThreadId").value = openai_thread_id;

        // setup event handler
        openai_event_handler = new EventHandler(openai)
        if (!openai_event_handler) {
          alert("Error: Unable to create event handler");
          return false;
        }
        openai_event_handler.on("event", openai_event_handler.onEvent.bind(openai_event_handler))
        return true;
      } else {
        alert("Error: Assistant not found. Please check your OpenAI API key and assistant name");
        return false;
      }
    }

    // get assistant response based on user input
    async function find_assistant(assistant_name) {
      // sanity check openai connection
      if (!openai) {
        return null;
      }

      try {
        // get a list of all assistants
        const assistants_list = await openai.beta.assistants.list({ order: "desc", limit: 20 });

        // iterate through assistants and find the one with the matching name
        let assistant = assistants_list.data.find(a => a.name === assistant_name);

        // return assistant ID if found, otherwise return null
        return assistant ? assistant.id : null;
      } catch (error) {
        // return null in case of an error
        return null;
      }
    }

    // create a new thread
    // returns thread id on success, null on failure
    async function create_thread() {
      // sanity check the assistant id
      if (!openai_assistant_id) {
        return null;
      }

      try {
        // create a thread
        const new_thread = await openai.beta.threads.create();
        return new_thread ? new_thread.id : null;
      } catch (error) {
        return null;
      }
    }

    // get assistant response based on user input
    async function get_assistant_response(input) {
      // sanity check the assistant id
      if (!openai_assistant_id) {
        return "get_assistant_response: assistant not found";
      }
      // sanity check thread
      if (!openai_thread_id) {
        return "get_assistant_response: thread not found";
      }

      // add a message to the thread
      const message = await openai.beta.threads.messages.create(openai_thread_id, { role: "user", content: input });

      // run the assistant
      const stream = await openai.beta.threads.runs.stream(openai_thread_id, { assistant_id: openai_assistant_id, stream: true })
      stream.on('event', (event) => openai_event_handler.emit("event", event))
    }

    // handle function call from assistant
    function handle_function_call(name, args) {
      add_text_to_debug("Function call: " + name + " with args: " + JSON.stringify(args));
      // call the function
      switch (name) {
        case "get_vehicle_type":
          // get the vehicle type (e.g. Copter, Plane, Rover, Boat, etc)
          return get_vehicle_type();
        case "get_parameter":
          // Get a vehicle parameter's value.  The full list of available parameters and their values is available using the get_all_parameters function
          // fallthrough
          add_text_to_debug("get_parameter args: " + JSON.stringify(args));
          return get_parameter(args);
        case "get_wakeup_timers":
          // Retrieves a list of all active wakeup timers. You can optionally provide a message parameter to filter timers by their associated messages. When specifying the message parameter, you can use regular expressions (regex) to match patterns within the timer messages. This is useful when you want to find timers with specific keywords or patterns in their messages. For example, to retrieve all timers containing the word 'hello', you can use the regex '.*hello.*', where the dot-star (.*) pattern matches any character sequence.
          // fallthrough
          add_text_to_debug("get_wakeup_timers: args: " + JSON.stringify(args));
          const wakeup_response = get_wakeup_timers(args);
          return wakeup_response;
        case "get_vehicle_location_and_yaw":
          // Get the vehicle's current location including latitude, longitude, altitude above sea level and altitude above home
          return get_vehicle_location_and_yaw()
        case "send_mavlink_set_position_target_global_int":
          // Send a mavlink SET_POSITION_TARGET_GLOBAL_INT message to the vehicle.  This message is the preferred way to command a vehicle to fly to a specified location or to fly at a specfied velocity
          // fallthrough
          add_text_to_debug("args: " + JSON.stringify(args));
          return send_mavlink_set_position_target_global_int(args);
        case "get_vehicle_state":
          // Get the vehicle state including armed status and (flight) mode
          add_text_to_debug("get_vehicle_state args: " + JSON.stringify(args));
          return get_vehicle_state();
        case "get_location_plus_offset":
          // Calculate the latitude and longitude given an existing latitude and longitude and distances (in meters) North and East
          // fallthrough
          add_text_to_debug("get_location_plus_offset args: " + JSON.stringify(args));
          const location_plus_offset = get_location_plus_offset(args);
          add_text_to_debug("get_location_plus_offset response: " + JSON.stringify(location_plus_offset));
          return location_plus_offset;
        case "send_mavlink_command_int":
          // Send a mavlink COMMAND_INT message to the vehicle.  Available commands including changing the flight mode, arming, disarming, takeoff and commanding the vehicle to fly to a specific location
          // fallthrough
          add_text_to_debug("args: " + JSON.stringify(args));
          const response = send_mavlink_command_int(args);
          return response;
        case "get_location_plus_dist_at_bearing":
          // Calculate the latitude and longitude given an existing latitude and longitude and a distance in meters and a bearing in degrees
          // fallthrough
          add_text_to_debug("get_location_plus_dist_at_bearing args: " + JSON.stringify(args));
          const location_plus_dist_at_bearing = get_location_plus_dist_at_bearing(args);
          add_text_to_debug("get_location_plus_dist_at_bearing response: " + JSON.stringify(location_plus_dist_at_bearing));
          return location_plus_dist_at_bearing;
        case "get_parameter_description":
        // Get vehicle parameter descriptions including description, units, min and max
        // fallthrough
        case "delete_wakeup_timers":
          // Delete all active wakeup timers. You can optionally provide a message parameter to filter which timers will be deleted based on their message. When specifying the message parameter, you can use regular expressions (regex) to match patterns within the timer messages. This is useful when you want to delete timers with specific keywords or patterns in their message. For example, to delete all timers containing the word 'hello', you can use the regex '.*hello.*', where the dot-star (.*) pattern matches any character sequence.
          // fallthrough
          return delete_wakeup_timers(args);
        case "set_parameter":
        // Set a vehicle parameter's value.  The full list of parameters is available using the get_all_parameters function
        // fallthrough
        case "get_mavlink_message":
          // Get a mavlink message including all fields and values sent by the vehicle.  The list of available messages can be retrieved using the get_available_mavlink_messages
          add_text_to_debug("Unknown function: " + name);
          return "Unknown function: " + name;
        case "get_current_datetime":
          // Get the current date and time, e.g. 'Saturday, June 24, 2023 6:14:14 PM
          add_text_to_debug("get_current_datetime called");
          return getFormattedDate();
        case "get_mode_mapping":
          // Get a list of mode names to mode numbers available for this vehicle.  If the name or number parameter is provided only that mode's name and number will be returned.  If neither name nor number is provided the full list of available modes will be returned
          // fallthrough
          const mode_mapping = get_mode_mapping(args);
          add_text_to_debug("get_mode_mapping response: " + JSON.stringify(mode_mapping));
          return mode_mapping;
        case "get_all_parameters":
        // Get all available parameter names and values
        // fallthrough
        case "set_wakeup_timer":
          // Set a timer to wake you up in a specified number of seconds in the future.  This allows taking actions in the future.  The wakeup message will appear with the user role but will look something like WAKEUP:<message>.  Multiple wakeup messages are supported
          return set_wakeup_timer(args);
        case "get_available_mavlink_messages":
          return get_available_mavlink_messages();
        default:
          add_text_to_debug("Unknown function: " + name);
          return "Unknown function: " + name;
      }
    }

    // function calls below here
    // returns "Copter", "Plane", "Rover", "Boat", etc or "Unknown"
    function get_vehicle_type() {
      // get the latest HEARTBEAT message and perform a sanity check
      let heartbeat_msg = mavlink_store.get_latest_message(0);
      //add_text_to_debug("get_vehicle_type: got latest msg" + JSON.stringify(heartbeat_msg));
      if (!heartbeat_msg || !heartbeat_msg.hasOwnProperty("type")) {
        return "unknown because no HEARTBEAT message has been received from the vehicle";
      }
      let vehicle_type = heartbeat_msg["type"];

      // get the vehicle type from the heartbeat message's type field
      switch (vehicle_type) {
        case mavlink20.MAV_TYPE_FIXED_WING:
        case mavlink20.MAV_TYPE_VTOL_DUOROTOR:
        case mavlink20.MAV_TYPE_VTOL_QUADROTOR:
        case mavlink20.MAV_TYPE_VTOL_TILTROTOR:
          return "Plane"
        case mavlink20.MAV_TYPE_GROUND_ROVER:
          return "Rover";
        case mavlink20.MAV_TYPE_SURFACE_BOAT:
          return "Boat";
        case mavlink20.MAV_TYPE_SUBMARINE:
          return "Sub";
        case mavlink20.MAV_TYPE_QUADROTOR:
        case mavlink20.MAV_TYPE_COAXIAL:
        case mavlink20.MAV_TYPE_HEXAROTOR:
        case mavlink20.MAV_TYPE_OCTOROTOR:
        case mavlink20.MAV_TYPE_TRICOPTER:
        case mavlink20.MAV_TYPE_DODECAROTOR:
          return "Copter";
        case mavlink20.MAV_TYPE_HELICOPTER:
          return "Heli";
        case mavlink20.MAV_TYPE_ANTENNA_TRACKER:
          return "Tracker";
        case mavlink20.MAV_TYPE_AIRSHIP:
          return "Blimp";
        default:
          add_text_to_debug("get_vehicle_type: default, unknown");
          return "unknown";
      }

      // if we got this far  we don't know the vehicle type
      add_text_to_debug("get_vehicle_type: no match for type:" + heartbeat_msg.type);
      return "unknown";
    }

    // return a mapping of mode names to numbers for the current vehicle type
    function get_mode_mapping(args) {
      if (typeof args === "string") {
        try {
          args = JSON.parse(args);
        } catch (e) {
          add_text_to_debug("get_mode_mapping: ERROR parsing args string");
          args = {};
        }
      }

      args = args || {};

      // get name and/or number arguments
      let mode_name = args.name ?? null;
      if (mode_name != null) {
        mode_name = mode_name.toUpperCase();
      }

      let mode_number = args.number ?? null;
      if (mode_number != null) {
        mode_number = parseInt(mode_number, 10);
      }

      // prepare list of modes
      let mode_list = [];
      let mode_mapping = {};

      const vehicle_type = get_vehicle_type();
      switch (vehicle_type) {
        case "Heli":
        case "Blimp":
        case "Copter":
          mode_mapping = {
            "STABILIZE": mavlink20.COPTER_MODE_STABILIZE,
            "ACRO": mavlink20.COPTER_MODE_ACRO,
            "ALT_HOLD": mavlink20.COPTER_MODE_ALT_HOLD,
            "AUTO": mavlink20.COPTER_MODE_AUTO,
            "GUIDED": mavlink20.COPTER_MODE_GUIDED,
            "LOITER": mavlink20.COPTER_MODE_LOITER,
            "RTL": mavlink20.COPTER_MODE_RTL,
            "CIRCLE": mavlink20.COPTER_MODE_CIRCLE,
            "LAND": mavlink20.COPTER_MODE_LAND,
            "DRIFT": mavlink20.COPTER_MODE_DRIFT,
            "SPORT": mavlink20.COPTER_MODE_SPORT,
            "FLIP": mavlink20.COPTER_MODE_FLIP,
            "AUTOTUNE": mavlink20.COPTER_MODE_AUTOTUNE,
            "POSHOLD": mavlink20.COPTER_MODE_POSHOLD,
            "BRAKE": mavlink20.COPTER_MODE_BRAKE,
            "THROW": mavlink20.COPTER_MODE_THROW,
            "AVOID_ADSB": mavlink20.COPTER_MODE_AVOID_ADSB,
            "GUIDED_NOGPS": mavlink20.COPTER_MODE_GUIDED_NOGPS,
            "SMART_RTL": mavlink20.COPTER_MODE_SMART_RTL,
            "FLOWHOLD": mavlink20.COPTER_MODE_FLOWHOLD,
            "FOLLOW": mavlink20.COPTER_MODE_FOLLOW,
            "ZIGZAG": mavlink20.COPTER_MODE_ZIGZAG,
            "SYSTEMID": mavlink20.COPTER_MODE_SYSTEMID,
            "AUTOROTATE": mavlink20.COPTER_MODE_AUTOROTATE,
            "AUTO_RTL": mavlink20.COPTER_MODE_AUTO_RTL
          };
          break;
        case "Plane":
          mode_mapping = {
            "MANUAL": mavlink20.PLANE_MODE_MANUAL,
            "CIRCLE": mavlink20.PLANE_MODE_CIRCLE,
            "STABILIZE": mavlink20.PLANE_MODE_STABILIZE,
            "TRAINING": mavlink20.PLANE_MODE_TRAINING,
            "ACRO": mavlink20.PLANE_MODE_ACRO,
            "FLY_BY_WIRE_A": mavlink20.PLANE_MODE_FLY_BY_WIRE_A,
            "FLY_BY_WIRE_B": mavlink20.PLANE_MODE_FLY_BY_WIRE_B,
            "CRUISE": mavlink20.PLANE_MODE_CRUISE,
            "AUTOTUNE": mavlink20.PLANE_MODE_AUTOTUNE,
            "AUTO": mavlink20.PLANE_MODE_AUTO,
            "RTL": mavlink20.PLANE_MODE_RTL,
            "LOITER": mavlink20.PLANE_MODE_LOITER,
            "TAKEOFF": mavlink20.PLANE_MODE_TAKEOFF,
            "AVOID_ADSB": mavlink20.PLANE_MODE_AVOID_ADSB,
            "GUIDED": mavlink20.PLANE_MODE_GUIDED,
            "INITIALIZING": mavlink20.PLANE_MODE_INITIALIZING,
            "QSTABILIZE": mavlink20.PLANE_MODE_QSTABILIZE,
            "QHOVER": mavlink20.PLANE_MODE_QHOVER,
            "QLOITER": mavlink20.PLANE_MODE_QLOITER,
            "QLAND": mavlink20.PLANE_MODE_QLAND,
            "QRTL": mavlink20.PLANE_MODE_QRTL,
            "QAUTOTUNE": mavlink20.PLANE_MODE_QAUTOTUNE,
            "QACRO": mavlink20.PLANE_MODE_QACRO,
            "THERMAL": mavlink20.PLANE_MODE_THERMAL
          };
          break;
        case "Boat":
        case "Rover":
          mode_mapping = {
            "MANUAL": mavlink20.ROVER_MODE_MANUAL,
            "ACRO": mavlink20.ROVER_MODE_ACRO,
            "STEERING": mavlink20.ROVER_MODE_STEERING,
            "HOLD": mavlink20.ROVER_MODE_HOLD,
            "LOITER": mavlink20.ROVER_MODE_LOITER,
            "FOLLOW": mavlink20.ROVER_MODE_FOLLOW,
            "SIMPLE": mavlink20.ROVER_MODE_SIMPLE,
            "AUTO": mavlink20.ROVER_MODE_AUTO,
            "RTL": mavlink20.ROVER_MODE_RTL,
            "SMART_RTL": mavlink20.ROVER_MODE_SMART_RTL,
            "GUIDED": mavlink20.ROVER_MODE_GUIDED,
            "INITIALIZING": mavlink20.ROVER_MODE_INITIALIZING
          };
          break;
        case "Sub":
          mode_mapping = {
            "STABILIZE": mavlink20.SUB_MODE_STABILIZE,
            "ACRO": mavlink20.SUB_MODE_ACRO,
            "ALT_HOLD": mavlink20.SUB_MODE_ALT_HOLD,
            "AUTO": mavlink20.SUB_MODE_AUTO,
            "GUIDED": mavlink20.SUB_MODE_GUIDED,
            "CIRCLE": mavlink20.SUB_MODE_CIRCLE,
            "SURFACE": mavlink20.SUB_MODE_SURFACE,
            "POSHOLD": mavlink20.SUB_MODE_POSHOLD,
            "MANUAL": mavlink20.SUB_MODE_MANUAL
          };
          break;
        case "Tracker":
          mode_mapping = {
            "MANUAL": mavlink20.TRACKER_MODE_MANUAL,
            "STOP": mavlink20.TRACKER_MODE_STOP,
            "SCAN": mavlink20.TRACKER_MODE_SCAN,
            "SERVO_TEST": mavlink20.TRACKER_MODE_SERVO_TEST,
            "AUTO": mavlink20.TRACKER_MODE_AUTO,
            "INITIALIZING": mavlink20.TRACKER_MODE_INITIALIZING
          };
          break;
        default:
          // maybe we don't know the vehicle type
          add_text_to_debug("get_mode_mapping: unknown vehicle type: " + vehicle_type);
          return `get_mode_mapping: failed to retrieve mode mapping: unknown vehicle type: ${vehicle_type}`;
      }

      // handle request for all modes
      if (mode_name === null && mode_number === null) {
        for (let mname in mode_mapping) {
          let mnumber = mode_mapping[mname];
          mode_list.push({ "name": mname.toUpperCase(), "number": mnumber });
        }
      }
      // handle request using mode name
      else if (mode_name !== null) {
        for (let mname in mode_mapping) {
          if (mname.toUpperCase() === mode_name) {
            mode_list.push({ "name": mname.toUpperCase(), "number": mode_mapping[mname] });
          }
        }
      }
      // handle request using mode number
      else if (mode_number !== null) {
        for (let mname in mode_mapping) {
          let mnumber = mode_mapping[mname];
          if (mnumber === mode_number) {
            mode_list.push({ "name": mname.toUpperCase(), "number": mnumber });
          }
        }
      }

      // return list of modes
      return mode_list;
    }

    // get a vehicle parameter's value
    function get_parameter(args) {
      // check if the parameter name is provided
      if (!args || !args.hasOwnProperty("name")) {
        add_text_to_debug("get_parameter: name not specified");
        return "get_parameter: name not specified";
      }
      const param_name = args.name;
      add_text_to_debug("get_parameter: name: " + param_name);
      const param_list = {};

      // handle param name containing regex
      if (contains_regex(param_name)) {
        for (const existing_param_name of all_params) {
          if (pattern.test(existing_param_name)) {
            if (param_value === null) {
              add_text_to_debug("get_parameter: unable to get " + existing_param_name);
            } else {
              param_list[existing_param_name] = param_value;
            }
          }
        }
      } else {
        // handle simple case of a single parameter name
        if (param_value === null) {
          return "get_parameter: " + param_name + " parameter not found";
        }
        param_list[param_name] = param_value;
      }

      return param_list;
    }

    // returns true if string contains regex characters
    function contains_regex(string) {
      const regex_characters = ".^$*+?{}[]\\|()";
      for (const char of regex_characters) {
        if (string.includes(char)) {
          return true;
        }
      }
      return false;
    }

    function send_mavlink_set_position_target_global_int(args) {
      if (!MAVLink || !mavlink_ws) {
        add_text_to_debug("MAVLink or WebSocket not ready");
        return { success: false, error: "MAVLink not initialized" };
      }

      if (typeof args === "string") {
        try {
          args = JSON.parse(args);
        } catch (e) {
          add_text_to_debug("ERROR: Could not parse args JSON");
          return "Invalid arguments: JSON parse error";
        }
      }

      try {
        const time_boot_ms = args.time_boot_ms ?? 0;
        const target_system = args.target_system ?? 1;
        if (!args.hasOwnProperty("target_system")) {
          add_text_to_debug("send_mavlink_set_position_target_global_int: target_system not specified, using default 1");
        } else {
          add_text_to_debug("send_mavlink_set_position_target_global_int: target_system: " + args.target_system);
        }
        // self.mpstate.settings.target_system bunun yerine ne yazmaliyiq bunu tap...
        // target_system = arguments.get("target_system", self.mpstate.settings.target_system)

        const target_component = args.target_component ?? 1;
        const coordinate_frame = args.coordinate_frame ?? 5;
        const type_mask = args.type_mask ?? 0; // ignore all position, velocity and acceleration except for the ones we set

        add_text_to_debug("target_component: " + target_component + ", coordinate_frame: " + coordinate_frame + ", type_mask: " + type_mask);
        // Position
        // const lat_int = args.latitude !== undefined ? int(args.latitude * 1e7) : 0;
        // const lon_int = args.longitude !== undefined ? int(args.longitude * 1e7) : 0;
        // const alt = args.alt ?? 0;
        add_text_to_debug("args.latitude: " + args.latitude + ", args.longitude: " + args.longitude + ", args.alt: " + args.alt);
        const lat_int = args.latitude !== undefined ? Math.round(args.latitude * 1e7) : 0;
        const lon_int = args.longitude !== undefined ? Math.round(args.longitude * 1e7) : 0;
        const alt = args.alt !== undefined ? args.alt : 0;  // in meters

        add_text_to_debug(`lat_int: ${lat_int}, lon_int: ${lon_int}, alt: ${alt}`);

        // Velocity
        const vx = args.vx ?? 0;
        const vy = args.vy ?? 0;
        const vz = args.vz ?? 0;

        // Acceleration (ignored if not needed)
        const afx = args.afx ?? 0;
        const afy = args.afy ?? 0;
        const afz = args.afz ?? 0;

        // Yaw and yaw_rate
        const yaw = args.yaw ?? 0;
        const yaw_rate = args.yaw_rate ?? 0;


        // sanity check arguments
        if (type_mask === 3576) {
          // if position is specified check lat, lon, alt are provided
          if (!args.hasOwnProperty("latitude")) {
            return "send_mavlink_set_position_target_global_int: latitude field required";
          }
          if (!args.hasOwnProperty("longitude")) {
            return "send_mavlink_set_position_target_global_int: longitude field required";
          }
          if (!args.hasOwnProperty("alt")) {
            return "send_mavlink_set_position_target_global_int: alt field required";
          }
        }

        const message = new mavlink20.messages.set_position_target_global_int(
          time_boot_ms, target_system, target_component,
          coordinate_frame, type_mask,
          lat_int, lon_int, alt,
          vx, vy, vz, afx, afy, afz,
          yaw, yaw_rate
        );
        add_text_to_debug("send_mavlink_set_position_target_global_int: message: " + JSON.stringify(message));

        const buffer = MAVLink.send(message);
        const uint = new Uint8Array(buffer);
        // console.log([...uint]);
        if (mavlink_ws && mavlink_ws.readyState === WebSocket.OPEN) {
          try {
            mavlink_ws.send(uint);
            // add_text_to_debug("send_mavlink_command_int: mav_result: " + mav_result);
          } catch (error) {
            add_text_to_debug("Error sending COMMAND_INT: " + error);
            return "command_int not sent.  Error sending COMMAND_INT: " + error;
          }
        } else {
          add_text_to_debug("WebSocket not open. Cannot send COMMAND_INT.");
        }
      } catch (error) {
        add_text_to_debug("Error sending SET_POSITION_TARGET_GLOBAL_INT: " + error);
      }

      return "set_position_target_global_int sent";
    }


    // send a mavlink COMMAND_INT message to the vehicle
    function send_mavlink_command_int(args) {
      if (!MAVLink || !mavlink_ws) {
        add_text_to_debug("MAVLink or WebSocket not ready");
        return { success: false, error: "MAVLink not initialized" };
      }

      add_text_to_debug("send_mavlink_command_int: args: " + args);
      const parsed = JSON.parse(args);
      add_text_to_debug("send_mavlink_command_int: parsed: " + JSON.stringify(parsed));
      add_text_to_debug("send_mavlink_command_int: command: " + parsed.command);
      if (!parsed.hasOwnProperty("command")) {
        add_text_to_debug("send_mavlink_command_int: command not found in args");
        return "command_int not sent.  command field required";
      }
      const command = parsed.command;
      const frame = parsed.frame || 0;
      const target_system = 1;
      const target_component = 1;
      const confirmation = 1;
      const param1 = parsed.hasOwnProperty("param1") ? parsed.param1 : 0;
      const param2 = parsed.hasOwnProperty("param2") ? parsed.param2 : 0;
      const param3 = parsed.hasOwnProperty("param3") ? parsed.param3 : 0;
      const param4 = parsed.hasOwnProperty("param4") ? parsed.param4 : 0;
      const x = parsed.hasOwnProperty("x") ? parsed.x : 0;
      const y = parsed.hasOwnProperty("y") ? parsed.y : 0;
      const z = parsed.hasOwnProperty("z") ? parsed.z : 0;

      // sanity check arguments
      if (command == 22 && z == 0) {
        return "command_int not sent.  MAV_CMD_NAV_TAKEOFF requires alt in z field"
      }

      // Build COMMAND_INT MAVLink message
      let command_long_msg = new mavlink20.messages.command_long(
        target_system, target_component,
        command, confirmation,
        param1, param2, param3, param4,
        x, y, z
      );
      const buffer = MAVLink.send(command_long_msg);
      const uint = new Uint8Array(buffer)
      if (mavlink_ws && mavlink_ws.readyState === WebSocket.OPEN) {
        try {
          mavlink_ws.send(uint);
          // add_text_to_debug("send_mavlink_command_int: mav_result: " + mav_result);
        } catch (error) {
          add_text_to_debug("Error sending COMMAND_INT: " + error);
          return "command_int not sent.  Error sending COMMAND_INT: " + error;
        }
      } else {
        add_text_to_debug("WebSocket not open. Cannot send COMMAND_INT.");
      }
      return "command_int succeeded";
    }

    // get the current time and date as a string. E.g. 'Saturday, June 24, 2023 6:14:14 PM'
    function getFormattedDate() {
      add_text_to_debug("getFormattedDate called");
      const options = {
        weekday: 'long',
        year: 'numeric',
        month: 'long',
        day: 'numeric',
        hour: 'numeric',
        minute: 'numeric',
        second: 'numeric',
        hour12: true
      };
      return new Date().toLocaleString('en-US', options);
    }

    // set a wakeup timer
    function set_wakeup_timer(args) {
      if (typeof args === "string") {
        try {
          args = JSON.parse(args);
        } catch (e) {
          add_text_to_debug("ERROR set_wakeup_timer: Could not parse args JSON");
          return "Invalid arguments: JSON parse error";
        }
      }

      // check required arguments are specified
      const seconds = args.seconds ?? -1;
      if (seconds < 0) {
        return "set_wakeup_timer: seconds not specified";
      }
      const message = args.message ?? null;
      if (message === null) {
        return "set_wakeup_timer: message not specified";
      }

      // add timer to wakeup schedule
      const triggerTime = Date.now() + seconds * 1000; // seconds → milliseconds → match Date.now()
      add_text_to_debug("set_wakeup_timer: triggerTime: " + new Date(triggerTime).toLocaleString());
      add_text_to_debug("current time: " + new Date(Date.now()).toLocaleString());
      wakeup_schedule.push({ time: triggerTime, message: message });
      add_text_to_debug("wakeup_schedule: " + JSON.stringify(wakeup_schedule));
      return "set_wakeup_timer: wakeup timer set";
    }

    // get wake timers
    function get_wakeup_timers(args) {
      if (typeof args === "string") {
        try {
          args = JSON.parse(args);
        } catch (e) {
          add_text_to_debug("ERROR set_wakeup_timer: Could not parse args JSON");
          return "Invalid arguments: JSON parse error";
        }
      }

      try {

        // check message argument, default to null meaning all
        const message = args.message ?? null;
        // prepare list of matching timers
        let matching_timers = [];

        // handle simple case of all timers
        if (message === null) {
          matching_timers = wakeup_schedule;
          add_text_to_debug("get_wakeup_timers: returning all timers");
        }

        // handle regex in message
        else if (contains_regex(message)) {
          const pattern = new RegExp(message, "i"); // ignore case
          for (const wakeup_timer of wakeup_schedule) {
            if (pattern.test(wakeup_timer.message)) {
              matching_timers.push(wakeup_timer);
            }
          }
          add_text_to_debug("get_wakeup_timers: returning timers matching regex: " + message);
        }

        // handle case of a specific message
        else {
          for (const wakeup_timer of wakeup_schedule) {
            if (wakeup_timer.message === message) {
              matching_timers.push(wakeup_timer);
            }
          }
          add_text_to_debug("get_wakeup_timers: returning timers matching message: " + message);
        }

        // return matching timers
        return matching_timers;

      } catch (e) {
        add_text_to_debug("ERROR get_wakeup_timers: " + e);
        return "Invalid arguments: JSON parse error";
      }
    }

    // delete wake timers
    function delete_wakeup_timers(args) {
      if (typeof args === "string") {
        try {
          args = JSON.parse(args);
        } catch (e) {
          add_text_to_debug("ERROR set_wakeup_timer: Could not parse args JSON");
          return "Invalid arguments: JSON parse error";
        }
      }

      // check message argument, default to all
      const message = args.message ?? null;

      // find matching timers
      let numDeleted = 0;

      add_text_to_debug("delete_wakeup_timers: message: " + message);
      // handle simple case of deleting all timers
      if (message === null) {
        numDeleted = wakeup_schedule.length;
        wakeup_schedule.length = 0;
        add_text_to_debug("delete_wakeup_timers: deleted all timers");
      }
      // handle regex in message
      else if (contains_regex(message)) {
        const pattern = new RegExp(message, "i");
        for (let i = wakeup_schedule.length - 1; i >= 0; i--) {
          if (pattern.test(wakeup_schedule[i].message)) {
            wakeup_schedule.splice(i, 1);
            numDeleted++;
          }
        }
        add_text_to_debug("delete_wakeup_timers: deleted timers matching regex: " + message);
      }
      // handle simple case of a single message
      else {
        for (let i = wakeup_schedule.length - 1; i >= 0; i--) {
          if (wakeup_schedule[i].message === message) {
            wakeup_schedule.splice(i, 1);
            numDeleted++;
          }
        }
        add_text_to_debug("delete_wakeup_timers: deleted timers matching message: " + message);
      }

      // return number deleted and remaining
      return `delete_wakeup_timers: deleted ${numDeleted} timers, ${wakeup_schedule.length} remaining`;
    }

    // check if any wakeup timers have expired and send messages if they have
    // this function never returns so it should be called from a new thread
    function check_wakeup_timers() {
      setInterval(() => {
        // check if any timers are set
        if (wakeup_schedule.length === 0) {
          return;
        }

        const now = Date.now();

        // iterate backward to safely remove expired timers
        for (let i = wakeup_schedule.length - 1; i >= 0; i--) {
          if (now >= wakeup_schedule[i].time) {
            const message = "WAKEUP:" + wakeup_schedule[i].message;
            add_text_to_debug("check_wakeup_timers: sending message: " + message);

            send_to_assistant(message);

            wakeup_schedule.splice(i, 1); // remove expired timer
          }
        }
      }, 1000); // wait for one second
    }


    //get the vehicle's location and yaw
    function get_vehicle_location_and_yaw() {
      // get GLOBAL_POSITION_INT
      const gpi = mavlink_store.get_latest_message(33);

      let lat_deg = 0
      let lon_deg = 0
      let alt_amsl_m = 0
      let alt_rel_m = 0
      let yaw_deg = 0

      if (gpi) {
        lat_deg = gpi.lat * 1e-7
        lon_deg = gpi.lon * 1e-7
        alt_amsl_m = gpi.alt * 1e-3
        alt_rel_m = gpi.relative_alt * 1e-3
        yaw_deg = gpi.hdg * 1e-2
      }

      const location = {
        "latitude": lat_deg,
        "longitude": lon_deg,
        "altitude_amsl": alt_amsl_m,
        "altitude_above_home": alt_rel_m,
        "yaw": yaw_deg
      }

      return location;
    }


    //get vehicle state
    function get_vehicle_state() {
      //get latest HEARTBEAT message
      const heartbeat_msg = mavlink_store.get_latest_message(0);
      //sanity check
      if (!heartbeat_msg || !heartbeat_msg.hasOwnProperty("base_mode") || !heartbeat_msg.hasOwnProperty("custom_mode")) {
        return "unknown because no HEARTBEAT message has been received from the vehicle";
      }
      //get the armed state flag by applying mask to base_model property
      const armed_flag = (heartbeat_msg["base_mode"] & mavlink20.MAV_MODE_FLAG_SAFETY_ARMED) > 0;
      //get mode number from custom_mode property
      const mode_number = heartbeat_msg["custom_mode"];

      return {
        "armed": armed_flag,
        "mode": mode_number
      }
    }

    // Calculate the latitude and longitude given distances (in meters) North and East
    function get_location_plus_offset(args) {
      // check if args is a string, if so, parse it
      if (typeof args === "string") {
        try {
          args = JSON.parse(args);
        } catch (e) {
          add_text_to_debug("ERROR: Could not parse args JSON");
          return "Invalid arguments: JSON parse error";
        }
      }

      const lat = args.latitude ?? 0;
      const lon = args.longitude ?? 0;
      const dist_north = args.distance_north ?? 0;
      const dist_east = args.distance_east ?? 0;
      const { latitude: lat_with_offset, longitude: lon_with_offset } =
        get_latitude_longitude_given_offset(lat, lon, dist_north, dist_east);

      add_text_to_debug("get_location_plus_offset: lat: " + lat + ", lon: " + lon + ", dist_north: " + dist_north + ", dist_east: " + dist_east);

      return {
        latitude: lat_with_offset,
        longitude: lon_with_offset
      };
    }

    // Calculate the latitude and longitude given a distance (in meters) and bearing (in degrees)
    function get_location_plus_dist_at_bearing(args) {
      add_text_to_debug("2get_location_plus_dist_at_bearing: args: " + JSON.stringify(args));

      // If args is a string, parse it
      if (typeof args === "string") {
        try {
          args = JSON.parse(args);
        } catch (e) {
          add_text_to_debug("get_location_plus_dist_at_bearing: ERROR parsing args string");
          return { latitude: 0, longitude: 0 };
        }
      }

      const lat = args.latitude ?? 0;
      const lon = args.longitude ?? 0;
      const distance = args.distance ?? 0;
      const bearing_deg = args.bearing ?? 0;

      const dist_north = Math.cos(bearing_deg * Math.PI / 180) * distance;
      const dist_east = Math.sin(bearing_deg * Math.PI / 180) * distance;

      const { latitude: lat_with_offset, longitude: lon_with_offset } =
        get_latitude_longitude_given_offset(lat, lon, dist_north, dist_east);

      add_text_to_debug(`get_location_plus_dist_at_bearing: lat: ${lat}, lon: ${lon}, distance: ${distance}, bearing: ${bearing_deg}`);

      return {
        latitude: lat_with_offset,
        longitude: lon_with_offset
      };


    }


    // wrap latitude to range -90 to 90
    function wrap_latitude(latitude_deg) {
      if (latitude_deg > 90) {
        return 180 - latitude_deg;
      }
      if (latitude_deg < -90) {
        return -(180 + latitude_deg);
      }
      return latitude_deg;
    }
    // wrap longitude to range -180 to 180
    function wrap_longitude(longitude_deg) {
      if (longitude_deg > 180) {
        return longitude_deg - 360;
      }
      if (longitude_deg < -180) {
        return longitude_deg + 360;
      }
      return longitude_deg;
    }

    // calculate latitude and longitude given distances (in meters) North and East
    // returns latitude and longitude in degrees
    function get_latitude_longitude_given_offset(latitude, longitude, dist_north, dist_east) {
      const lat_lon_to_meters_scaling = 89.8320495336892 * 1e-7;
      const lat_diff = dist_north * lat_lon_to_meters_scaling;
      const lon_diff = dist_east * lat_lon_to_meters_scaling / Math.max(0.01, Math.cos((latitude + lat_diff) * Math.PI / 180 / 2));
      return {
        latitude: wrap_latitude(latitude + lat_diff),
        longitude: wrap_longitude(longitude + lon_diff)
      };
    }

    class EventHandler extends EventEmitter {
      constructor(client) {
        super()
        this.client = client;
      }

      async onEvent(event) {
        try {
          // print status on html page
          document.getElementById("assistantRunStatus").value = event.event;

          // handle each event
          switch (event.event) {
            // retrieve events that are denoted with 'requires_action'
            // since these will have our tool_calls
            case "thread.run.requires_action":
              await this.handleRequiresAction(
                event.data,
                event.data.id,
                event.data.thread_id,
              )
              break;
            case "thread.message.delta":
            case "thread.run.step.delta":
              let delta_text = event.data.delta.content[0].text.value
              add_text_to_chat(delta_text, "assistant")
              break;

            // events below can be ignored
            case "thread.created":
            case "thread.message.completed":
            case "thread.run.created":
            case "thread.run.queued":
            case "thread.run.in_progress":
            case "thread.run.completed":
            case "thread.run.incomplete":
            case "thread.run.failed":
            case "thread.run.step.created":
            case "thread.run.cancelling":
            case "thread.run.step.in_progress":
            case "thread.run.cancelled":
            case "thread.run.expired":
            case "thread.run.step.created":
            case "thread.run.step.in_progress":
            case "thread.run.step.completed":
            case "thread.run.step.failed":
            case "thread.run.step.cancelled":
            case "thread.run.step.expired":
            case "thread.message.created":
            case "thread.message.in_progress":
            case "thread.message.completed":
            case "thread.message.incomplete":
            case "error":
            case "done":
              break;

            // catch unhandled events
            default:
              add_text_to_debug("Unhandled event: " + event.event)
              console.log(event)
          }

        } catch (error) {
          console.error("Error handling event:", error)
        }
      }

      // handle requires action event by calling a local function and returning the result to the assistant
      async handleRequiresAction(data, runId, threadId) {
        try {
          const toolOutputs = data.required_action.submit_tool_outputs.tool_calls.map((toolCall) => {
            let output = handle_function_call(toolCall.function.name, toolCall.function.arguments)
            output = JSON.stringify(output);
            add_text_to_debug("fn:" + toolCall.function.name + " output:" + output)
            return {
              tool_call_id: toolCall.id,
              output: output
            }
          })
          // submit all the tool outputs at the same time
          await this.submitToolOutputs(toolOutputs, runId, threadId)
        } catch (error) {
          console.error("Error processing required action:", error)
        }
      }

      // return function call results to the assistant
      async submitToolOutputs(toolOutputs, runId, threadId) {
        try {
          // use the submitToolOutputsStream helper
          const stream = this.client.beta.threads.runs.submitToolOutputsStream(
            threadId,
            runId,
            { tool_outputs: toolOutputs },
          )
          for await (const event of stream) {
            this.emit("event", event)
          }
        } catch (error) {
          console.error("Error submitting tool outputs:", error)
        }
      }
    }
  </script>

  <script type="module">
    import OpenAI from "https://cdn.jsdelivr.net/npm/openai@4.85.4/+esm";

    // Access the global OpenAI instance safely
    const openai = window.openai;

    // add text to chat box
    function add_text_to_chat(text, role = "assistant") {
      let div_class = role === "assistant" ? "assistant-text" : "user-text";
      let chatBox = document.getElementById("chatBox");

      if (role === "assistant") {
        // try to find the last assistant message and append to it
        let last_message = chatBox.querySelector(`.${div_class}:last-of-type`);
        if (last_message) {
          last_message.textContent += text;
          chatBox.scrollTop = chatBox.scrollHeight;
          return;
        }
      }

      // create a new message div if no previous assistant message exists
      let message_div = document.createElement("div");
      message_div.className = div_class;
      message_div.textContent = text;
      chatBox.appendChild(message_div);
      chatBox.scrollTop = chatBox.scrollHeight;
    }

    // add text to debug text box
    function add_text_to_debug(text) {
      let debugOutput = document.getElementById("debugOutput");
      debugOutput.value += text + "\n";
      debugOutput.scrollTop = debugOutput.scrollHeight;
    }

    // send a message to the assistant, used for wakeup messages
    async function send_to_assistant(message) {
      // check connection
      if (!(await check_connection())) {
        return;
      }

      // show the message in chat as system or wakeup message
      add_text_to_chat(message, "user"); // use "system" or custom style class
      // debugmu?

      // get assistant response
      let response = await get_assistant_response(message);

      // show assistant response
      add_text_to_chat(response, "assistant");
      // debugmu?
    }

    // get assistant response based on user input
    async function get_assistant_response(input) {
      // sanity check the assistant id
      if (!openai_assistant_id) {
        return "get_assistant_response: assistant not found";
      }
      // sanity check thread
      if (!openai_thread_id) {
        return "get_assistant_response: thread not found";
      }

      // add a message to the thread
      const message = await openai.beta.threads.messages.create(openai_thread_id, { role: "user", content: input });

      // run the assistant
      const stream = await openai.beta.threads.runs.stream(openai_thread_id, { assistant_id: openai_assistant_id, stream: true })
      stream.on('event', (event) => openai_event_handler.emit("event", event))
    }



    const recordButton = document.getElementById("recordButton");

    const state = {
      mediaRecorder: null,
      audioChunks: [],
      stream: null,
      audioBlob: null,
      isRecording: false,
      listeners: {
        dataavailable: null,
        stop: null
      }
    };

    async function startRecording(options = {}) {
      if (state.isRecording) {
        add_text_to_debug("recording is in progress");
        return;
      }

      state.isRecording = true;
      state.audioChunks = [];

      try {
        const defaultOptions = {
          mimeType: "audio/webm",
          audioBitsPerSecond: 128000
        };
        const recordingOptions = { ...defaultOptions, ...options };

        state.stream = await navigator.mediaDevices.getUserMedia({
          audio: {
            echoCancellation: true,
            noiseSuppression: true,
            autoGainControl: true
          }
        });

        if (MediaRecorder.isTypeSupported(recordingOptions.mimeType)) {
          state.mediaRecorder = new MediaRecorder(state.stream, recordingOptions);
        } else {
          add_text_to_debug(recordingOptions.mimeType + " is not supported, using default codec");
          state.mediaRecorder = new MediaRecorder(state.stream);
        }

        state.listeners.dataavailable = event => {
          state.audioChunks.push(event.data);
        };

        state.listeners.stop = async () => {
          state.audioBlob = new Blob(state.audioChunks, { type: recordingOptions.mimeType });
          cleanupResources();
          await handleTranscription(state.audioBlob);
        };

        state.mediaRecorder.addEventListener("dataavailable", state.listeners.dataavailable);
        state.mediaRecorder.addEventListener("stop", state.listeners.stop);
        state.mediaRecorder.start();

      } catch (error) {
        state.isRecording = false;
        cleanupResources();
        add_text_to_debug("Error accessing microphone: " + error);
      }
    }

    function stopRecording() {
      if (!state.mediaRecorder || state.mediaRecorder.state === "inactive") {
        return false;
      }
      state.mediaRecorder.stop();
      return true;
    }

    function cleanupResources() {
      if (state.stream) {
        state.stream.getTracks().forEach(track => track.stop());
        state.stream = null;
      }
      if (state.mediaRecorder) {
        if (state.listeners.dataavailable) {
          state.mediaRecorder.removeEventListener("dataavailable", state.listeners.dataavailable);
        }
        if (state.listeners.stop) {
          state.mediaRecorder.removeEventListener("stop", state.listeners.stop);
        }
        state.mediaRecorder = null;
      }
      state.isRecording = false;
    }

    async function handleTranscription(blob) {
      try {
        const formData = new FormData();
        formData.append("file", blob, "recording.webm");
        formData.append("model", "whisper-1");
        // update this static language option with dynamic in future , let user choose language
        formData.append("language", "en");

        const resp = await fetch("https://api.openai.com/v1/audio/transcriptions", {
          method: "POST",
          headers: { "Authorization": `Bearer ${openai.apiKey}` },
          body: formData
        });
        const data = await resp.json();
        const transcript = data.text.trim();
        add_text_to_chat(transcript, "user");
        const response = await get_assistant_response(transcript);
        add_text_to_chat(response, "assistant");
      } catch (err) {
        add_text_to_debug("Transcription error: " + err);
      }
    }

    recordButton.addEventListener("click", () => {
      if (state.isRecording) {
        stopRecording();
      } else {
        startRecording().catch(err => {
          add_text_to_debug("Failed to start recording: " + err);
        });
      }
    });
  </script>

</body>

</html>