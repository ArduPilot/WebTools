<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Chat</title>
  <link rel="icon" href="../images/AP_favicon.png">
  <script type="text/javascript" src="MAVLink/mavlink.js"></script>
</head>
<table style="width:1200px">
  <tr>
    <td>
      <a href="https://ardupilot.org"><img src="../images/ArduPilot.png"></a>
    </td>
    <td>
      <a href="https://github.com/ArduPilot/WebTools"><img src="../images/github-mark.png" style="width:60px"></a><br>
      <a href="https://github.com/ArduPilot/WebTools"><img src="../images/GitHub_Logo.png" style="width:60px"></a>
    </td>
  </tr>
</table>

<style>
    body {
        font-family: Arial, sans-serif;
    }
    .chat-container {
        width: 400px;
        border: 1px solid #ccc;
        border-radius: 5px;
        padding: 10px;
        background-color: #f9f9f9;
    }
    .chat-box {
        width: 100%;
        height: 200px;
        border: 1px solid #ccc;
        background-color: white;
        padding: 5px;
        overflow-y: auto;
    }
    .user-text {
        color: red;
    }
    .assistant-text {
        color: black;
    }
    .input-container {
        display: flex;
        margin-top: 10px;
    }
    .input-field {
        flex: 1;
        padding: 5px;
    }
    .send-button {
        margin-left: 5px;
    }
</style>

<h1><a href="" style="color: #000000; text-decoration:none;">Chat</a></h1>

<body>
  <div class="chat-container">
    <div class="chat-box" id="chatBox"></div>
    <div class="input-container">
        <button id="sendButton">Rec</button>
        <input type="text" id="userInput" class="input-field" placeholder="Type a message...">
        <button class="send-button" id="sendMessageButton" >Send</button>
    </div>
  </div>

  <!-- OpenAI API key input field -->
  <div class="openaiapi-key-container">
    <label for="openai_api_key">OpenAI API Key:</label>
    <input type="password" id="openai_api_key" class="input-field">
    <button onclick="toggle_openai_api_key_visibility()">üëÅÔ∏è</button>
  </div>

  <!-- read-only input for Assistant ID -->
  <div class="assistant-id-container">
    <label for="assistantId">assistant id:</label>
    <input type="text" id="assistantId" class="input-field" readonly>
  </div>

  <!-- read-only input for assistant thread id -->
  <div class="assistant-thread-container">
    <label for="assistantThreadId">thread id:</label>
    <input type="text" id="assistantThreadId" class="input-field" readonly>
  </div>

  <!-- read-only input for Assistant status -->
  <div class="assistant-run-status-container">
    <label for="assistantRunStatus">run status:</label>
    <input type="text" id="assistantRunStatus" class="input-field" readonly>
  </div>

  <!-- MAVLink connection button -->
  <div class="mavlink-connection-container">
      <label for="MAVLinkConnection">MAVLink Connect:</label>
      <input type="text" id="mavlink-connect-url" class="input-field" value="ws://127.0.0.1:56781" readonly>
      <button id="mavlink-connect-button">Connect</button>
  </div>

  <!-- MAVLink arming button -->
  <div class="mavlink-arm-container">
      <label for="mavlink-arm-vehicle">Arm Vehicle</label>
      <button id="mavlink-arm-button">Arm</button>
  </div>

  <!-- debug output text box -->
  <div class="debug-output-container">
      <textarea id="debugOutput" class="input-field" rows="10" readonly></textarea>
  </div>

  <!-- simple script functions local to this page -->
  <script type="module">
    // imports
    import { mavlink_store } from './MAVLink/mavlink_store.js';

    // show/hide the OpenAI API key field
    function toggle_openai_api_key_visibility() {
        let openai_key_input = document.getElementById("openai_api_key");
        openai_key_input.type = openai_key_input.type === "password" ? "text" : "password";
    }

    // MAVLink connection related functions
    let connect_button = document.getElementById("mavlink-connect-button");
    let is_connected = false; // connection state
    let mavlink_ws = null; // websocket object
    let mavlink_sysid = 254; // system id
    let mavlink_compid = MAVLink20Processor.MAV_COMP_ID_MISSIONPLANNER; // component id
    let MAVLink = new MAVLink20Processor(null, mavlink_sysid, mavlink_compid);

    // toggle connection state (called by Connect/Disconnect button)
    function mavlink_toggle_connect() {
        if (is_connected) {
            mavlink_disconnect();
        } else {
            mavlink_connect();
        }
    }

    // attach event listener to the connect button
    if (connect_button) {
        connect_button.addEventListener("click", mavlink_toggle_connect);
    }

    // set the mavlink button connection state
    function mavlink_set_connect_state(connected) {
        is_connected = connected;
        if (connected) {
            connect_button.innerText = "Disconnect";
        } else {
            connect_button.innerText = "Connect";
        }
    }

    // connect to the vehicle
    function mavlink_connect() {
        // check connection URL
        let connect_url = document.getElementById("mavlink-connect-url").value;
        if (!connect_url) {
            alert("Error: WebSocket URL is empty");
            return;
        }

        if (mavlink_ws == null) {
            // create a new websocket connection
            mavlink_ws = new WebSocket(connect_url);
            mavlink_ws.binaryType = "arraybuffer"

            // set up event handlers
            mavlink_ws.onopen = function() {
                mavlink_set_connect_state(true);
            };
            mavlink_ws.onclose = function() {
                mavlink_set_connect_state(false);
            };
            mavlink_ws.onerror = function() {
                mavlink_disconnect();
            };

            // parse incoming message and forward
            mavlink_ws.onmessage = (msg) => {
                // sanity check parser has been created
                if (MAVLink == null) {
                    return;
                }
                // parse message
                for (const char of new Uint8Array(msg.data)) {
                    const mavlink_msg = MAVLink.parseChar(char)
                    if ((mavlink_msg != null) && (mavlink_msg._id != -1)) {
                        // got a message with a known ID
                        mavlink_msg_handler(mavlink_msg);
                    }
                }
            }
        }
    }

    // disconnect from the vehicle
    function mavlink_disconnect() {
        if (mavlink_ws != null) {
            mavlink_ws.close();
            mavlink_ws = null;
        }
    }

    // mavlink message handler
    function mavlink_msg_handler(msg) {

        // sanity check msg
        if (msg == null || msg._id == null) {
            return;
        }

        // store the message in the message store
        mavlink_store.store_message(msg);

        switch (msg._id) {
            case 0: // HEARTBEAT
                //alert("custom mode:" + msg.custom_mode);
                //alert("Got a heartbeat: " + JSON.stringify(msg));
                break;
            case 1: // SYS_STATUS
                //alert("Got a system status: " + JSON.stringify(msg));
                break;
            case 24: // GPS_RAW_INT
                //alert("Got a GPS raw int: " + JSON.stringify(msg));
                break;
            case 30: // ATTITUDE
                //alert("Got an attitude: " + JSON.stringify(msg));
                break;
            case 33: // GLOBAL_POSITION_INT
                //alert("Got a global position int: " + JSON.stringify(msg));
                break;
            case 35: // HIGHRES_IMU
                //alert("Got a high resolution IMU: " + JSON.stringify(msg));
                break;
            case 42: // NAMED_VALUE_FLOAT
                //alert("Got a named value float: " + JSON.stringify(msg));
                break;
            case 74: // VFR_HUD
                //alert("Got a VFR HUD: " + JSON.stringify(msg));
                break;
            case 253: // STATUSTEXT
                //alert("Got a status text: " + JSON.stringify(msg));
                break;
            default:
                //alert("Got a message id: " + JSON.stringify(msg));
                break;
        }
    }

    // arm the vehicle
    function mavlink_arm_vehicle() {
        if (mavlink_ws == null || mavlink_ws.readyState !== WebSocket.OPEN) {
            alert("Please connect to the vehicle first");
            return;
        }
        // construct the ARM command using COMMAND_LONG
        let command_long_msg = new mavlink20.messages.command_long(
            1,   // Target system ID
            1,  // Target component ID
            400,             // MAV_CMD_COMPONENT_ARM_DISARM (command ID 400)
            1,               // Confirmation
            1,               // Param1: 1 to arm, 0 to disarm
            0, 0, 0, 0, 0, 0 // Unused parameters
        );

        const buffer = MAVLink.send(command_long_msg)
        const uint = new Uint8Array(buffer)

        // send the message as an ArrayBuffer over the WebSocket
        if (mavlink_ws && mavlink_ws.readyState === WebSocket.OPEN) {
            mavlink_ws.send(uint);
            add_text_to_debug("Sent ARM command via MAVLink");
        } else {
            alert("WebSocket is not open. Cannot send ARM command.");
        }
    }
    // attach event listener to the arm button
    document.getElementById("mavlink-arm-button").addEventListener("click", mavlink_arm_vehicle);

    // add text to debug text box
    function add_text_to_debug(text) {
        let debugOutput = document.getElementById("debugOutput");
        debugOutput.value += text + "\n";
        debugOutput.scrollTop = debugOutput.scrollHeight;
    }
</script>

<script type="module">
  // error handling
  window.onerror = function(msg, url, linenumber) {
      alert('Sorry, something went wrong.\n\n' + 
            'Please try a hard reload of this page to clear its cache.\n\n' +
            'If the error persists open an issue on the GitHub repo.\n' +
            'Include a copy of the log and the following error message:\n\n' +
            msg + '\n' +
            'URL: '+ url +'\n' +
            'Line Number: '+ linenumber)
      return false
  }
  window.addEventListener('unhandledrejection', function (e) {
      throw new Error(e.reason.stack)
  })

  // imports
  import OpenAI from 'https://cdn.jsdelivr.net/npm/openai@4.85.4/+esm'
  import EventEmitter from 'https://cdn.jsdelivr.net/npm/eventemitter3@5.0.1/+esm'
  import { mavlink_store } from './MAVLink/mavlink_store.js';

  // constants
  const OPENAI_API_KEY = ""; // replace with your OpenAI API key
  const OPENAI_MODEL = "gpt-4o"
  const OPENAI_ASSISTANT_NAME = "ArduPilot Vehicle Control via MAVLink"

  // global variables
  let openai = null
  let openai_assistant_id = null
  let openai_thread_id = null
  let openai_event_handler = null

  // chat listener for user input and enter key
  document.getElementById("userInput").addEventListener("keypress", function(event) {
      if (event.key === "Enter") {
          send_message();
      }
  })
  // listener for send message button click
  document.getElementById("sendMessageButton").addEventListener("click", send_message);

  // get openai API key (use this in API calls)
  function get_openai_api_key() {
      if (OPENAI_API_KEY.length > 0) {
          return OPENAI_API_KEY;
      }
      return document.getElementById("openai_api_key").value.trim();
  }

  // check connection
  check_connection();

  // add text to chat box
  function add_text_to_chat(text, role = "assistant") {
      let div_class = role === "assistant" ? "assistant-text" : "user-text";
      let chatBox = document.getElementById("chatBox");

      if (role === "assistant") {
          // try to find the last assistant message and append to it
          let last_message = chatBox.querySelector(`.${div_class}:last-of-type`);
          if (last_message) {
              last_message.textContent += text;
              chatBox.scrollTop = chatBox.scrollHeight;
              return;
          }
      }

      // create a new message div if no previous assistant message exists
      let message_div = document.createElement("div");
      message_div.className = div_class;
      message_div.textContent = text;
      chatBox.appendChild(message_div);
      chatBox.scrollTop = chatBox.scrollHeight;
  }

  // add text to debug text box
  function add_text_to_debug(text) {
      let debugOutput = document.getElementById("debugOutput");
      debugOutput.value += text + "\n";
      debugOutput.scrollTop = debugOutput.scrollHeight;
  }

  // send message to AI assistant, get response and place in chat box text area
  async function send_message() {
      // check connection to OpenAI
      if (!(await check_connection())) {
          return;
      }

      let userInput = document.getElementById("userInput").value;
      if (!userInput.trim()) return;

      // display user input and clear input field
      add_text_to_chat(userInput, "user");
      document.getElementById("userInput").value = "";

      // fetch response from assistant
      let response = await get_assistant_response(userInput);

      // display assistant response
      add_text_to_chat(response, "assistant");
  }

  //
  // methods below here interact directly with the OpenAI API
  //

  // check connection to OpenAI API and return true on succes, false on failure
  async function check_connection() {
      // check openai API key
      if (!get_openai_api_key()) {
          return false;
      }
      // check openai connection
      if (!openai) {
          openai = new OpenAI({apiKey: get_openai_api_key(), dangerouslyAllowBrowser: true});
          if (!openai) {
              return false;
          }
      }

      // return immediately if assistant id has already been found
      if (openai_assistant_id) {
          return true
      }

      let assistantId = await find_assistant(OPENAI_ASSISTANT_NAME);
      if (assistantId) {
          // store assistant id
          openai_assistant_id = assistantId
          document.getElementById("assistantId").value = assistantId;

          // create a new thread
          openai_thread_id = await create_thread();
          if (!openai_thread_id) {
              alert("Error: Unable to create a new OpenAI thread");
              return false;
          }
          // print thread id on the page
          document.getElementById("assistantThreadId").value = openai_thread_id;

          // setup event handler
          openai_event_handler = new EventHandler(openai)
          if (!openai_event_handler) {
              alert("Error: Unable to create event handler");
              return false;
          }
          openai_event_handler.on("event", openai_event_handler.onEvent.bind(openai_event_handler))
          return true;
      } else {
          alert("Error: Assistant not found. Please check your OpenAI API key and assistant name");
          return false;
      }
  }

  // get assistant response based on user input
  async function find_assistant(assistant_name) {
      // sanity check openai connection
      if (!openai) {
          return null;
      }

      try {
          // get a list of all assistants
          const assistants_list = await openai.beta.assistants.list({order: "desc", limit: 20});

          // iterate through assistants and find the one with the matching name
          let assistant = assistants_list.data.find(a => a.name === assistant_name);

          // return assistant ID if found, otherwise return null
          return assistant ? assistant.id : null;
      } catch (error) {
          // return null in case of an error
          return null;
      }
  }

  // create a new thread
  // returns thread id on success, null on failure
  async function create_thread() {
    // sanity check the assistant id
    if (!openai_assistant_id) {
        return null;
    }

    try {
        // create a thread
        const new_thread = await openai.beta.threads.create();
        return new_thread ? new_thread.id : null;
    } catch (error) {
        return null;
    }
  }

  // get assistant response based on user input
  async function get_assistant_response(input) {
      // sanity check the assistant id
      if (!openai_assistant_id) {
          return "get_assistant_response: assistant not found";
      }
      // sanity check thread
      if (!openai_thread_id) {
          return "get_assistant_response: thread not found";
      }

      // add a message to the thread
      const message = await openai.beta.threads.messages.create(openai_thread_id, { role: "user", content: input });

      // run the assistant
      const stream = await openai.beta.threads.runs.stream(openai_thread_id, { assistant_id: openai_assistant_id, stream: true })
      stream.on('event', (event) => openai_event_handler.emit("event", event))
  }

  // handle function call from assistant
  function handle_function_call(name, args) {
      add_text_to_debug("Function call: " + name + " with args: " + JSON.stringify(args));
      // call the function
      switch (name) {
          case "get_vehicle_type":
              // get the vehicle type (e.g. Copter, Plane, Rover, Boat, etc)
              return get_vehicle_type();
          case "get_parameter":
              // Get a vehicle parameter's value.  The full list of available parameters and their values is available using the get_all_parameters function
              // fallthrough
          case "get_wakeup_timers":
              // Retrieves a list of all active wakeup timers. You can optionally provide a message parameter to filter timers by their associated messages. When specifying the message parameter, you can use regular expressions (regex) to match patterns within the timer messages. This is useful when you want to find timers with specific keywords or patterns in their messages. For example, to retrieve all timers containing the word 'hello', you can use the regex '.*hello.*', where the dot-star (.*) pattern matches any character sequence.
              // fallthrough
          case "get_vehicle_location_and_yaw":
              // Get the vehicle's current location including latitude, longitude, altitude above sea level and altitude above home
              return get_vehicle_location_and_yaw()
          case "send_mavlink_set_position_target_global_int":
              // Send a mavlink SET_POSITION_TARGET_GLOBAL_INT message to the vehicle.  This message is the preferred way to command a vehicle to fly to a specified location or to fly at a specfied velocity
              // fallthrough
          case "get_vehicle_state":
              // Get the vehicle state including armed status and (flight) mode
              return get_vehicle_state();
          case "get_location_plus_offset":
              // Calculate the latitude and longitude given an existing latitude and longitude and distances (in meters) North and East
              // fallthrough
          case "send_mavlink_command_int":
              // Send a mavlink COMMAND_INT message to the vehicle.  Available commands including changing the flight mode, arming, disarming, takeoff and commanding the vehicle to fly to a specific location
              // fallthrough
          case "get_location_plus_dist_at_bearing":
              // Calculate the latitude and longitude given an existing latitude and longitude and a distance in meters and a bearing in degrees
              // fallthrough
          case "get_parameter_description":
              // Get vehicle parameter descriptions including description, units, min and max
              // fallthrough
          case "delete_wakeup_timers":
              // Delete all active wakeup timers. You can optionally provide a message parameter to filter which timers will be deleted based on their message. When specifying the message parameter, you can use regular expressions (regex) to match patterns within the timer messages. This is useful when you want to delete timers with specific keywords or patterns in their message. For example, to delete all timers containing the word 'hello', you can use the regex '.*hello.*', where the dot-star (.*) pattern matches any character sequence.
              // fallthrough
          case "set_parameter":
              // Set a vehicle parameter's value.  The full list of parameters is available using the get_all_parameters function
              // fallthrough
          case "get_mavlink_message":
              // Get a mavlink message including all fields and values sent by the vehicle.  The list of available messages can be retrieved using the get_available_mavlink_messages
              add_text_to_debug("Unknown function: " + name);
              return "Unknown function: " + name;
          case "get_current_datetime":
              // Get the current date and time, e.g. 'Saturday, June 24, 2023 6:14:14 PM
              return getFormattedDate();
          case "get_mode_mapping":
              // Get a list of mode names to mode numbers available for this vehicle.  If the name or number parameter is provided only that mode's name and number will be returned.  If neither name nor number is provided the full list of available modes will be returned
              // fallthrough
          case "get_all_parameters":
              // Get all available parameter names and values
              // fallthrough
          case "set_wakeup_timer":
              // Set a timer to wake you up in a specified number of seconds in the future.  This allows taking actions in the future.  The wakeup message will appear with the user role but will look something like WAKEUP:<message>.  Multiple wakeup messages are supported
              add_text_to_debug("Unknown function: " + name);
              return "Unknown function: " + name;
          case "get_available_mavlink_messages":
              return get_available_mavlink_messages();
          default:
              add_text_to_debug("Unknown function: " + name);
              return "Unknown function: " + name;
      }
  }

    // function calls below here
    // returns "Copter", "Plane", "Rover", "Boat", etc or "Unknown"
    function get_vehicle_type() {

        // get the latest HEARTBEAT message and perform a sanity check
        let heartbeat_msg = mavlink_store.get_latest_message(0);
        //add_text_to_debug("get_vehicle_type: got latest msg" + JSON.stringify(heartbeat_msg));
        if (!heartbeat_msg || !heartbeat_msg.hasOwnProperty("type")) {
            return "unknown because no HEARTBEAT message has been received from the vehicle";
        }
        let vehicle_type = heartbeat_msg["type"];

        // get the vehicle type from the heartbeat message's type field
        switch (vehicle_type) {
            case mavlink20.MAV_TYPE_FIXED_WING:
            case mavlink20.MAV_TYPE_VTOL_DUOROTOR:
            case mavlink20.MAV_TYPE_VTOL_QUADROTOR:
            case mavlink20.MAV_TYPE_VTOL_TILTROTOR:
                return "Plane"
            case mavlink20.MAV_TYPE_GROUND_ROVER:
                return "Rover";
            case mavlink20.MAV_TYPE_SURFACE_BOAT:
                return "Boat";
            case mavlink20.MAV_TYPE_SUBMARINE:
                return "Sub";
            case mavlink20.MAV_TYPE_QUADROTOR:
            case mavlink20.MAV_TYPE_COAXIAL:
            case mavlink20.MAV_TYPE_HEXAROTOR:
            case mavlink20.MAV_TYPE_OCTOROTOR:
            case mavlink20.MAV_TYPE_TRICOPTER:
            case mavlink20.MAV_TYPE_DODECAROTOR:
                return "Copter";
            case mavlink20.MAV_TYPE_HELICOPTER:
                return "Heli";
            case mavlink20.MAV_TYPE_ANTENNA_TRACKER:
                return "Tracker";
            case mavlink20.MAV_TYPE_AIRSHIP:
                return "Blimp";
            default:
                add_text_to_debug("get_vehicle_type: default, unknown");
                return "unknown";
        }

        // if we got this far  we don't know the vehicle type
        add_text_to_debug("get_vehicle_type: no match for type:" + hearbeat_msg.type);
        return "unknown";
    }

    // get names of all available mavlink messages
    function get_available_mavlink_messages() {
        // get the available message names
        let msg_names = mavlink_store.get_available_message_names();
        if (!msg_names) {
            return "No available messages";
        }
        return msg_names.join(", ");
    }

  // get the current time and date as a string. E.g. 'Saturday, June 24, 2023 6:14:14 PM'
  function getFormattedDate() {
      const options = {
          weekday: 'long', 
          year: 'numeric', 
          month: 'long', 
          day: 'numeric', 
          hour: 'numeric', 
          minute: 'numeric', 
          second: 'numeric', 
          hour12: true 
      };
      return new Date().toLocaleString('en-US', options);
  }

  //get the vehicle's location and yaw
  function get_vehicle_location_and_yaw() {
    // get GLOBAL_POSITION_INT
    const gpi = mavlink_store.get_latest_message(33);

    let lat_deg = 0
    let lon_deg = 0
    let alt_amsl_m = 0
    let alt_rel_m = 0
    let yaw_deg = 0

    if (gpi) {
        lat_deg = gpi.lat * 1e-7
        lon_deg = gpi.lon * 1e-7
        alt_amsl_m = gpi.alt * 1e-3
        alt_rel_m = gpi.relative_alt * 1e-3
        yaw_deg = gpi.hdg * 1e-2
    }

    const location = {
            "latitude": lat_deg,
            "longitude": lon_deg,
            "altitude_amsl": alt_amsl_m,
            "altitude_above_home": alt_rel_m,
            "yaw" : yaw_deg
        }
    
    return location;
  }


    //get vehicle state
    function get_vehicle_state(){
        //get latest HEARTBEAT message
        const heartbeat_msg = mavlink_store.get_latest_message(0);
        //sanity check
        if (!heartbeat_msg || !heartbeat_msg.hasOwnProperty("base_mode") || !heartbeat_msg.hasOwnProperty("custom_mode")) {
            return "unknown because no HEARTBEAT message has been received from the vehicle";
        }
        //get the armed state flag by applying mask to base_model property
        const armed_flag = (heartbeat_msg["base_mode"] & mavlink20.MAV_MODE_FLAG_SAFETY_ARMED) > 0;
        //get mode number from custom_mode property
        const mode_number = heartbeat_msg["custom_mode"];
        
        return {
            "armed": armed_flag,
            "mode": mode_number
        }
    }

  class EventHandler extends EventEmitter {
        constructor(client) {
            super()
            this.client = client;
        }

        async onEvent(event) {
            try {
                // print status on html page
                document.getElementById("assistantRunStatus").value = event.event;

                // handle each event
                switch (event.event) {
                // retrieve events that are denoted with 'requires_action'
                // since these will have our tool_calls
                case "thread.run.requires_action":
                    await this.handleRequiresAction(
                        event.data,
                        event.data.id,
                        event.data.thread_id,
                    )
                    break;
                case "thread.message.delta":
                case "thread.run.step.delta":
                    let delta_text = event.data.delta.content[0].text.value
                    add_text_to_chat(delta_text, "assistant")
                    break;

                // events below can be ignored
                case "thread.created":
                case "thread.message.completed":
                case "thread.run.created":
                case "thread.run.queued":
                case "thread.run.in_progress":
                case "thread.run.completed":
                case "thread.run.incomplete":
                case "thread.run.failed":
                case "thread.run.step.created":
                case "thread.run.cancelling":
                case "thread.run.step.in_progress":
                case "thread.run.cancelled":
                case "thread.run.expired":
                case "thread.run.step.created":
                case "thread.run.step.in_progress":
                case "thread.run.step.completed":
                case "thread.run.step.failed":
                case "thread.run.step.cancelled":
                case "thread.run.step.expired":
                case "thread.message.created":
                case "thread.message.in_progress":
                case "thread.message.completed":
                case "thread.message.incomplete":
                case "error":
                case "done":
                    break;

                // catch unhandled events
                default:
                    add_text_to_debug("Unhandled event: " + event.event)
                    console.log(event)
                }

            } catch (error) {
                console.error("Error handling event:", error)
            }
        }

        // handle requires action event by calling a local function and returning the result to the assistant
        async handleRequiresAction(data, runId, threadId) {
            try {
                const toolOutputs = data.required_action.submit_tool_outputs.tool_calls.map((toolCall) => {
                    let output = handle_function_call(toolCall.function.name, toolCall.function.arguments)
                    output = JSON.stringify(output);
                    add_text_to_debug("fn:" + toolCall.function.name + " output:" + output)
                    return {
                        tool_call_id: toolCall.id,
                        output: output
                    }
                })

                // submit all the tool outputs at the same time
                await this.submitToolOutputs(toolOutputs, runId, threadId)
            } catch (error) {
                console.error("Error processing required action:", error)
            }
        }

        // return function call results to the assistant
        async submitToolOutputs(toolOutputs, runId, threadId) {
            try {
                // use the submitToolOutputsStream helper
                const stream = this.client.beta.threads.runs.submitToolOutputsStream(
                    threadId,
                    runId,
                    { tool_outputs: toolOutputs },
                )
                for await (const event of stream) {
                    this.emit("event", event)
                }
            } catch (error) {
                console.error("Error submitting tool outputs:", error)
            }
        }
    }
</script>
</body>
</html>
